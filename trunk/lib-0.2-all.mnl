-- lib-0.2-all.mnl

/*    Copyright (C) 2018, 2019 Alexey Protasov (AKA Alex or rusini)

   This file is part of MANOOL.

   MANOOL is free software: you can redistribute it and/or modify it under the terms of the version 3 of the GNU General Public License
   as published by the Free Software Foundation (and only version 3).

   MANOOL is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along with MANOOL.  If not, see <http://www.gnu.org/licenses/>.  */


{ {extern "_base"} in
: {extern "_runtime"} in
: {extern "_ieee754-dec"} in
: {extern "_ieee754-cmpx"} in
: {extern "_streams"} in
: {extern "_threads"} in

: let
  { (') =
    { macro
    : proc { F } as
    : if Size[F] <> 2 then {array} else -- syntax error
      F[1]#
    }
  }
  in
: let
  { ($) =
    { macro
    : proc { F } as
    : if Size[F] <> 2 then {array} else -- syntax error
    : array of let# {array of: array of (=)' Res' F[1]} in' Res'
    }
    (%) =
    { macro
    : proc { F } as
    : if Size[F] <> 2 then {array} else -- syntax error
    : array of
    : array of macro#
    : array of proc# {array of MakeSym[]} as' F[1]
    }
    do =
    { macro
    : proc { F } as
      {array of let# {array} in'} + F[Range[1; Size[F]]]
    }
    on =
    { macro
    : proc { F } as
    : if (Size[F] >= 6) & (F[2] == do') & (F[4] == after') then -- {on K do B after B; B; ...}
      {array of on# F[1] with' MakeSym[] do' F[3] after'} + F[Range[5; Size[F]]]
      else -- fallback
      {array of on#} + F[Range[1; Size[F]]]
    }
    signal =
    { macro
    : proc { F } as
    : if (Size[F] == 2) then -- {signal V}
      {array of signal# F[1] with' Nil#}
      else -- fallback
      {array of signal#} + F[Range[1; Size[F]]]
    }
  }
  in
: let
  { do =
    { macro
    : proc { F } as
    : if (Size[F] >= 4) & (F[2] == after') then -- {do E after B; ...}
      {array of do#} + F[Range[3; Size[F]]] | F[1]
      else -- fallback
      {array of do#} + F[Range[1; Size[F]]]
    }
    on =
    { macro
    : proc { F } as
    : if F[1] == broad' then -- {on broad ...}
      {array of on#} + F[Range[2; Size[F]]]
      else
    : if (Size[F] >= 8) & (F[2] == do') & (F[4] == with') & (F[6] == after') then -- {on K with I do B after B; B; ...}
      { var { Sym = MakeSym[] } in
      : array of let# {array of: array of (=)' Sym MakeSym[]} in'
      : array of on# Sym with' F[3] do' F[5] after' {array of let# {array of: array of (=)' F[1] Sym} in'} + F[Range[7; Size[F]]]
      }
      else
    : if (Size[F] >= 6) & (F[2] == do') & (F[4] == after') then -- {on K do B after B; B; ...}
      { var { Sym = MakeSym[] } in
      : array of let# {array of: array of (=)' Sym MakeSym[]} in'
      : array of on# Sym do' F[3] after' {array of let# {array of: array of (=)' F[1] Sym} in'} + F[Range[5; Size[F]]]
      }
      else -- fallback
      {array of on#} + F[Range[1; Size[F]]]
    }
  }
  in
: let
  { for =
    { macro
    : proc { F } as
    : if (Size[F] == 4) & (F[2] == (&)') then -- {for {I = V; I = V; ...} (&) C}
      { var { Exit = MakeSym[] } in
      : array of on# broad' Exit do' False# after'
      : array of do# True# after'
      : array of for# F[1] do'
      : array of if# {array of (~)# F[3]} then'
      : array of signal# Exit
      }
      else
    : if (Size[F] == 4) & (F[2] == (|)') then -- {for {I = V; I = V; ...} (|) C}
      { var { Exit = MakeSym[] } in
      : array of on# broad' Exit do' True# after'
      : array of do# False# after'
      : array of for# F[1] do'
      : array of if# F[3] then'
      : array of signal# Exit
      }
      else
    : if (Size[F] == 5) & (F[2] == array') & (F[3] == of')
      then -- {for {I = V; I = V; ...} array of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of array#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of (=)# Sym {array of (|)# {array of (!)# Sym} F[4]}
      }
      else
    : if (Size[F] == 5) & (F[2] == sequence') & (F[3] == of')
      then -- {for {I = V; I = V; ...} sequence of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of sequence#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of (=)# Sym {array of (|)# {array of (!)# Sym} F[4]}
      }
      else
    : if (Size[F] == 5) & (F[2] == set') & (F[3] == of')
      then -- {for {I = V; I = V; ...} set of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of set#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of (=)# {array of Sym F[4]} True#
      }
      else
    : if (Size[F] == 5) & (F[2] == map') & (F[3] == of') & F[4].IsList[] & (Size[F[4]] == 3) & (F[4; 0] == (=)')
      then -- {for {I = V; I = V; ...} map of K = V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of map#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of (=)# {array of Sym F[4; 1]} F[4; 2]
      }
      else
    : if (Size[F] == 7) & (F[2] == if') & (F[4] == array') & (F[5] == of')
      then -- {for {I = V; I = V; ...} if C array of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of array#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of if# F[3] then'
      : array of (=)# Sym {array of (|)# {array of (!)# Sym} F[6]}
      }
      else
    : if (Size[F] == 7) & (F[2] == if') & (F[4] == sequence') & (F[5] == of')
      then -- {for {I = V; I = V; ...} if C sequence of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of sequence#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of if# F[3] then'
      : array of (=)# Sym {array of (|)# {array of (!)# Sym} F[6]}
      }
      else
    : if (Size[F] == 7) & (F[2] == if') & (F[4] == set') & (F[5] == of')
      then -- {for {I = V; I = V; ...} if C set of V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of set#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of if# F[3] then'
      : array of (=)# {array of Sym F[6]} True#
      }
      else
    : if (Size[F] == 7) & (F[2] == if') & (F[4] == map') & (F[5] == of') & F[6].IsList[] & (Size[F[6]] == 3) & (F[6; 0] == (=)')
      then -- {for {I = V; I = V; ...} if C map of K = V}
      { var { Sym = MakeSym[] } in
      : array of var# {array of: array of (=)' Sym: array of map#} in'
      : array of do# Sym after'
      : array of for# F[1] do'
      : array of if# F[3] then'
      : array of (=)# {array of Sym F[6; 1]} F[6; 2]
      }
      else -- fallback
      {array of for#} + F[Range[1; Size[F]]]
    }
  }
  in
: let
  { let =
    { macro
    : proc { F } as
    : if (Size[F] >= 4) & (F[2] == in') & F[1].IsList[] & {for {E = F[1]} (&) E.IsSym[]}
      then -- {let {I; ...} in B; ...}
      {array of let# {for {E = F[1]} array of: array of (=)' E: if Str[E][Range[0; 1]] <> "_" then E# else MakeSym[]} in'} + F[Range[3; Size[F]]]
      else -- fallback
      {array of let#} + F[Range[1; Size[F]]]
    }
    export =
    { macro
    : proc { F } as
    : if (Size[F] >= 2) & {for {E = F[Range[1; Size[F]]]} (&) E.IsList[] & (Size[E] == 3) & (E[0] == (=)') & E[1].IsSym[]}
      then -- {export I = E; ...}
      {array of let# F[Range[1; Size[F]]] in' {array of export#} + {for {E = F[Range[1; Size[F]]]} array of E[1]}}
      else -- fallback
      {array of export#} + F[Range[1; Size[F]]]
    }
    do =
    { macro
    : proc { F } as
    : if (Size[F] >= 4) & (F[2] == where') & {for {E = F[Range[3; Size[F]]]} (&) E.IsList[] & (Size[E] == 3) & (E[0] == (=)') & E[1].IsSym[]}
      then -- {do E where I = E; ...}
      {var {Res = F[1]} in: do Res after: for {E = F[Range[3; Size[F]]]} do Res = {array of let# {array of E} in' Res}}
      else -- fallback
      {array of do#} + F[Range[1; Size[F]]]
    }
    object =
    { macro
    : proc { F } as
    : if (Size[F] >= 4) & (F[2] == with') & {for {E = F[1; Range[Size[F[1]]]] + F[Range[3; Size[F]]]} (&) E.IsList[] & (Size[E] == 3) & (E[0] == (=)')}
      then -- {object {K = V; ...} with K = V; ...}
      {array of object# F[1] cleanup' Nil# with'} + F[Range[3; Size[F]]]
      else
    : if (Size[F] >= 2) & {for {E = F[Range[1; Size[F]]]} (&) E.IsList[] & (Size[E] == 3) & (E[0] == (=)')}
      then -- {object K = V; ...}
      {array of object# F[Range[1; Size[F]]] cleanup' Nil#}
      else -- fallback
      {array of object#} + F[Range[1; Size[F]]]
    }
  }
  in

: let
  { on =
    { macro
    : proc { F } as
    : if (Size[F] >= 8) & (F[2] == revert') & (F[4] == do') & (F[6] == after') & F[3].IsList[]
      then -- {on K revert {V; ...} do B after B; B; ...}
      { var {U = {for {_ = F[3].Keys[]} array of MakeSym[]}} in
      : array of var# {for {U = U; V = F[3]} array of: array of (=)' U V} in'
        { array of on# F[1]
          do' {array of do#} + {for {U = U; V = F[3]} array of: array of (=)# V: array of (!)# U}[RevRange[Size[U]]] | F[5] after'
        } + F[Range[7; Size[F]]]
      }
      else
    : if (Size[F] >= 10) & (F[2] == with') & (F[4] == revert') & (F[6] == do') & (F[8] == after') & F[5].IsList[]
      then -- {on K with I revert {V; ...} do B after B; B; ...}
      { var {U = {for {_ = F[5].Keys[]} array of MakeSym[]}} in
      : array of var# {for {U = U; V = F[5]} array of: array of (=)' U V} in'
        { array of on# F[1] with' F[3]
          do' {array of do#} + {for {U = U; V = F[5]} array of: array of (=)# V: array of (!)# U}[RevRange[Size[U]]] | F[7] after'
        } + F[Range[9; Size[F]]]
      }
      else
    : if (Size[F] >= 9) & (F[1] == broad') & (F[3] == revert') & (F[5] == do') & (F[7] == after') & F[4].IsList[]
      then -- {on broad K revert {V; ...} do B after B; B; ...}
      { var {U = {for {_ = F[4].Keys[]} array of MakeSym[]}} in
      : array of var# {for {U = U; V = F[4]} array of: array of (=)' U V} in'
        { array of on# broad' F[2]
          do' {array of do#} + {for {U = U; V = F[4]} array of: array of (=)# V: array of (!)# U}[RevRange[Size[U]]] | F[6] after'
        } + F[Range[8; Size[F]]]
      }
      else
    : if (Size[F] >= 11) & (F[1] == broad') & (F[3] == with') & (F[5] == revert') & (F[7] == do') & (F[9] == after') & F[6].IsList[]
      then -- {on broad K with I revert {V; ...} do B after B; B; ...}
      { var {U = {for {_ = F[6].Keys[]} array of MakeSym[]}} in
      : array of var# {for {U = U; V = F[6]} array of: array of (=)' U V} in'
        { array of on# broad' F[2] with' F[4]
          do' {array of do#} + {for {U = U; V = F[6]} array of: array of (=)# V: array of (!)# U}[RevRange[Size[U]]] | F[8] after'
        } + F[Range[10; Size[F]]]
      }
      else -- fallback
      {array of on#} + F[Range[1; Size[F]]]
    }
  }
  in

: let
  { assign =
    { macro
    : proc { F } as
    : if (Size[F] == 2) & F[1].IsList[] & (Size[F[1]] == 3) & (F[1; 0] == (=)') then -- {assign D = S}
      {var {Sym = MakeSym[]} in: array of var# {array of: array of (=)' Sym F[1; 2]} in' {array of (=)# F[1; 1] Sym}; Sym}
      else
    : if
      (Size[F] >= 2) &
      { on _Invalid do False after: do True after
      : for {I = Range[1; Size[F]]} do: if ~(F[I].IsList[] & (Size[F[I]] == 3) & (F[I; 0] == (=)')) then: signal _Invalid
      }
      then -- {assign D = S; ...}
      { var { Ids = {array} } in {for {_ = Range[1; Size[F]]} do Ids = Ids! + {array of MakeSym[]}}
        {array of var# {var {Res = {array}} in {for {I = Range[1; Size[F]]} do Res = Res! + {array of: array of (=)' Ids[I - 1] F[I; 2]}}; Res} in'} +
        {var {Res = {array}} in {for {I = RevRange[1; Size[F]]} do Res = Res! + {array of: array of (=)' F[I; 1] Ids[I - 1]}}; Res}
      }
      else -- syntax error
      {array}
    }
  }
  in
: let
  { unless =
    { macro
    : proc { F } as
    : if (Size[F] >= 8) & (F[2] == signal') & (F[4] == with') & (F[6] == else') then -- {unless C signal K with V else B; B; ...}
      {array of if# {array of (~)# F[1]} then' {array of signal# F[3] with' F[5]} else'} + F[Range[7; Size[F]]]
      else
    : if (Size[F] >= 6) & (F[2] == signal') & (F[4] == else') then -- {unless C signal K else B; B; ...}
      {array of if# {array of (~)# F[1]} then' {array of signal# F[3]} else'} + F[Range[5; Size[F]]]
      else: array -- error
    }
    ensure =
    { macro
    : proc { F } as
    : if (Size[F] >= 4) & (F[2] == in') then -- {ensure C in E} \ {ensure C in B; B; B; ...}
      {array of (%)#: array of if# F[1] then' ({array of do#} + F[Range[3; Size[F]]])# else' {array of error# "Test failed"}#}
      else: array -- error
    }
  }
  in
: let
  { E  = {proc {T} as Exp[T[1]]}
    Pi = {proc {T} as Acos[T[(~1)$]]}
    I  = {proc {T} as Sqrt[T[(~1)$]]}
  }
  in

: export
  ('); if; (&); (|); while; repeat; do; on; signal
  for; case
  (=); (!); (^); assign
  proc; var; let; ($)
  array; record; map; set; sequence
  object; (@)
  export; scope
  macro; (#); error; eval; (%)
  unless; ensure
  True; False; Nil
  F64; F32; I48; MakeSym; S8; U32; D64; D128; C64; C128; Z64; Z32
  MakePtr
  Range; RevRange; RangeExt; RevRangeExt
  IsI48; IsF64; IsF32; IsS8; IsU32; IsBool; IsNull
  IsArray; IsMap; IsSet; IsSequence
  IsSym; IsPtr; IsWeakPtr
  IsList; IsForm
  IsRange; IsRevRange
  Parse
  VarArg; VarApply
  Min; Max; E; Pi; I
  ProcessArgv; ProcessEnviron; ProcessExit; ReserveStack; ReserveHeap
  Out; Err; In; OpenFile; OpenPipe; OpenTemp
  StartThread; MakeMutex; MakeCond
}
