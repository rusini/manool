
Usage: mnl [<runtime opt>]... [<startup opt>]... <expr> [<arg>]...
       -- Parse[] <expr>, Eval[] it in the standard module context (as in
          {{extern "mnt/std/1.0/all"} in <expr>}) and Write[] result to stdout
       -- useful for quick testing (<expr> shall not start with '-')
          in MANOOL: Out.WriteLine[{array of {extern "mnt/std/1.0/all"}# in' (<file>).ReadFile[].Parse[<file>]}.Eval[]]

  or:  mnl [<runtime opt>]... [<startup opt>]... -- <file> [<arg>]...
       -- Load as callable (e. g. {proc}) from <file>, apply it to
          the array of <arg> and use result as the exit status
       -- normal mode for shebang scripts (ignores shebang line as well)
          in MANOOL: (<file>).ReadFile[].Parse[<file>].Eval[][{array of (<arg>)...}]

  or:  mnl [<runtime opt>]... [<startup opt>]... ((-f|--file) <file> | (-f|--file)=<file> | -f<file>) [<arg>]...
       -- Load from <file> and eval directly (<arg>s and establishing exit status are available using auxiliary APIs)
          in MANOOL: (<file>).ReadFile[].Parse[<file>].Eval[]

  or:  mnl [<runtime opt>]... [<startup opt>]... ((-e|--expr) <expr> | (-e|--expr)=<expr> | -e<expr>) [<arg>]...
       -- Same but load directly from argument <expr>
          in MANOOL: (<expr>).Parse[].Eval[]

  or:  mnl [<runtime opt>]... [<startup opt>]... - [<arg>]...
       -- Same but load from stdin
          in MANOOL: "".ReadFile[].Parse["<standard input>"].Eval[]

  or:  mnl [<runtime opt>]... [<startup opt>]...
       -- Same as just 'mnl [<runtime opt>]... [<startup opt>]... -'

[<runtime opt>]... options (options effect is cumulative):
  (-p|--path) <path> | (-p|--path)=<path> | -p<path>
  Prepend MNL_PATH environment variable with '<path>:'
  -q|--quiet
  Suppress any diagnostic output to stderr on MANOOL panic (security-centric option)
  (-S|--stack) <size> | (-S|--stack)=<size> | -S<size>
  (-H|--heap) <size> | (-H|--heap)=<size> | -H<size>

[<startup opt>]... options (options effect is cumulative):
  None for now.

Environment variables:
  MNL_PATH
  MNL_STARTUP




namespace aux {
   string do_readfile(const string &path) {
      constexpr int
         page_size = 1024 * 4, buf_size = 1024 * 1024 * 16;
      auto fd = ::open(path.c_str(), O_RDONLY);
      if (MNL_UNLIKELY(fd == -1)) MNL_ERR(MNL_SYM("PosixOpenFailed"));
      auto _finally_fd = finally([&]{ if (MNL_UNLIKELY(::close(*this)) && !uncaught_exception()) MNL_ERR(MNL_SYM("PosixCloseFailed")); });
      struct ::stat st; if (MNL_UNLIKELY(::fstat(fd, &st))) MNL_ERR(MNL_SYM("PosixFstatFailed"));
      if (S_ISREG(st.st_mode) && st.st_size > page_size) {
         auto ptr = ::mmap({}, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
         if (MNL_UNLIKELY(ptr == MAP_FAILED)) MNL_ERR(MNL_SYM("PosixMmapFailed"));
         auto _finally_ptr = finally([&]{ if(MNL_UNLIKELY(::munmap(*this, st_size)) && !uncaught_exception()) MNL_ERR(MNL_SYM("PosixMunmapFailed")); });
         if (MNL_UNLIKELY(::posix_madvise(ptr, st.st_size, POSIX_MADV_WILLNEED))) MNL_ERR(MNL_SYM("PosixMadviseFailed"));
         return string(static_cast<const char *>(implicit_cast<void *>(ptr)), st.st_size);
      }
      return [&]()->string{
         string res;
         for (;;) {
            res.resize(res.size() + buf_size);
            int count = read(fd, &res.front() + res.size() - buf_size, buf_size);
            if (MNL_UNLIKELY(count == -1)) MNL_ERR(MNL_SYM("PosixReadFailed"));
            res.resize(res.size() - buf_size + count);
            if (MNL_UNLIKELY(!count)) return res;
         }
      }();
   }
} // namespace aux
